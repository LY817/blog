---
layout: post
title: 缓存双写一致性
tags:
- Redis
- 程序设计
date: 2020-05-05 10:06:58
author:     "LuoYu"
permalink:
categories:
description:
keywords:
---

## Cache Aside Pattern

查询接口添加缓存的基本逻辑

- 查询时先检查缓存数据库中是否有数据

  - 如果有直接返回
  - 如果没有 查询数据库并将数据存入缓存数据库 再返回

- 当数据库中的数据发送改变后，会将缓存中对应的数据失效

  懒加载思想 下一次查询时再从数据库中加载



## 数据不一致场景&解决方案演进

### 先更新数据库 再删除缓存【脏读】

因为数据库操作和缓存操作，分别对两个中间件进行操作，无法构成一个本地事务。

可能出现修改数据库成功，但是删除缓存失败（网络原因）。导致缓存中的”老数据“被客户端访问，直到下一次更新操作成功删除缓存，客户端才能访问到正确的数据。

### 先删除缓存 再更新数据库【并发脏读】

可以避免**低并发场景下的脏读**的问题：先删除缓存，如果更新数据库失败，当下一次读请求时，也会访问数据库获取正确的数据。

在并发读写的场景下，还是会出现脏读

在对一个资源的更新操作执行的过程中，删除了缓存，但还没更新数据库

另一个**相同资源**的读请求，发现缓存为空，就会重新读取数据库中**还未更新的记录**，并存到缓存中

后面的读请求还是读取的旧数据

### 根据资源标识串行化执行更新和查询【最终方案】

上述出现并发脏读的原因是**同一个资源**在同一时间**并发的进行更新和查询操作**

解决的方式是将同一资源的更新和查询操作串行化，来保证不会出现并发脏读的情况。

实现思路是将更新和查询操作封装成任务，根据资源的唯一标识hash到JVM中对应的阻塞队列中，每个阻塞队列对应一个线程死循环消费任务队列中的任务